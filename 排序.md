# 十大经典排序算法

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [十大经典排序算法](#十大经典排序算法)
  - [算法概述](#算法概述)
    - [算法分类](#算法分类)
    - [算法复杂度](#算法复杂度)
    - [相关概念](#相关概念)
  - [1、冒泡排序（Bubble Sort)](#1-冒泡排序bubble-sort)
    - [1.1算法描述](#11算法描述)
    - [1.2动图演示](#12动图演示)
    - [1.3代码实现](#13代码实现)
    - [1.4算法分析](#14算法分析)
  - [2、选择排序（Selection Sort）](#2-选择排序selection-sort)
    - [2.1算法描述](#21算法描述)
    - [2.2动图演示](#22动图演示)
    - [2.3代码实现](#23代码实现)
    - [2.4算法分析](#24算法分析)
  - [3、插入排序（Insertion Sort)](#3-插入排序insertion-sort)
    - [3.1算法描述](#31算法描述)
    - [3.2动图演示](#32动图演示)
    - [3.3代码实现](#33代码实现)
    - [3.4算法分析](#34算法分析)
  - [4、希尔排序（Shell Sort)](#4-希尔排序shell-sort)
    - [4.1 算法描述](#41-算法描述)
    - [4.2 动画演示](#42-动画演示)
    - [4.3 代码实现](#43-代码实现)
    - [4.4算法分析](#44算法分析)
  - [5、归并排序（Merge Sort)](#5-归并排序merge-sort)
    - [5.1 算法描述](#51-算法描述)
    - [5.2 动图演示](#52-动图演示)
    - [5.3 代码实现](#53-代码实现)
    - [5.4 算法分析](#54-算法分析)
  - [6、快速排序（Quick Sort)](#6-快速排序quick-sort)
    - [6.1 算法描述](#61-算法描述)
    - [6.2 动图演示](#62-动图演示)
    - [6.3 代码实现](#63-代码实现)
    - [6.4 算法分析](#64-算法分析)
  - [7、堆排序（Heap Sort）](#7-堆排序heap-sort)
    - [7.1 算法描述](#71-算法描述)
    - [7.2 动图演示](#72-动图演示)
    - [7.3 代码实现](#73-代码实现)
    - [7.4 算法分析](#74-算法分析)
  - [8、计数排序（Counting Sort）](#8-计数排序counting-sort)
    - [8.1算法描述](#81算法描述)
    - [8.2动图演示](#82动图演示)
    - [8.3代码实现](#83代码实现)
    - [8.4算法分析](#84算法分析)
  - [9、桶排序（Bucket Sort）](#9-桶排序bucket-sort)
    - [9.1算法描述](#91算法描述)
    - [10.2动图演示](#102动图演示)
    - [10.3代码实现void](#103代码实现void)
    - [10.4算法分析](#104算法分析)

<!-- /code_chunk_output -->

## 算法概述
### 算法分类
十钟常见排序算法可以分为两大类：
比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O（nlogn),因此也称为非线性时间比较类排序
非比较类排序：不通过比较来决定元素的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。
![排序算法分类](./utils/排序算法分类.png)
### 算法复杂度
![算法复杂度](./utils/排序算法复杂度.png)
### 相关概念
稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
不稳定：如果a原本在b前面，而a=b，排序之后a可能会出现在b的后面。
时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。

## 1、冒泡排序（Bubble Sort)
冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 
### 1.1算法描述
1、比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3、针对所有的元素重复以上的步骤，除了最后一个；
4、重复步骤1~3，直到排序完成。
### 1.2动图演示
![冒泡排序](./utils/冒泡排序.gif)
### 1.3代码实现
```c++
void bubbleSort(vector<int> arr) {
    int len = arr.size();
    bool didSwap;
    for (int i = 0; i < len - 1; i++) {
        didSwap = false;//这个标志位的作用是能保证好的情况不需要遍历剩下的情况了
        for (int j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j+1]) {        // 相邻元素两两对比
                int temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
        if(didSwap == false)
            return;
    }
}
```
### 1.4算法分析
因为双层循环，平均时间复杂度为$O(n^2)$，最坏时间复杂度出现在递减数列的情况下为$O(n^2)$，最好情况出现在递增数列的情况下为$O(n)$。
## 2、选择排序（Selection Sort）
选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 
### 2.1算法描述
n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：
·初始状态：无序区为R[1..n]，有序区为空；
·第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
·n-1趟结束，数组有序化了。
### 2.2动图演示
![选择排序](./utils/选择排序.gif)
### 2.3代码实现
```c++
void selectionSort(vector<int> arr)
{
    int len =arr.size();
    int minIndex,temp;
    for (int i = 0; i < len - 1; i++) {
    minIndex = i;
        for (int j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}
```
### 2.4算法分析
表现最稳定的排序算法之一，因为双循环，且需要全部比较一遍，所以无论什么数据进去都是$O(n^2)$的时间复杂度，因此用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。

## 3、插入排序（Insertion Sort)
插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
### 3.1算法描述
一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：
1、从第一个元素开始，该元素可以认为已经被排序；
2、取出下一个元素，在已经排序的元素序列中从后向前扫描；
3、如果该元素（已排序）大于新元素，将该元素移到下一位置；
4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5、将新元素插入到该位置后；
6、重复步骤2~5。
### 3.2动图演示
![插入排序](./utils/插入排序.gif)
### 3.3代码实现
```c++
void insertionSort(vector<int> arr)
{
    int len =arr.size();
    int preIndex, current;
    for (int i = 1; i < len - 1; i++) {
    preIndex = i-1;
    current= arr[i];
    while(preIndex>=0&&arr[preIndex]>current)
    {
        arr[preIndex+1]=arr[preIndex];
        preIndex--;
    }
    arr[preIndex+1]=current;       
    }
}
```
### 3.4算法分析
插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。平均时间复杂度为$O(n^2)$,最坏情况为递减数列，时间复杂度为$O(n^2)$；最好情况为递增数列，时间复杂度为$O(n)$

## 4、希尔排序（Shell Sort)
1959年Shell发明，第一个突破$O(n^2)$的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。
### 4.1 算法描述
先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：
假如数组长度为n
·选择一个增量序列t1，t2，t3，…，tk，其中t1=n/2，t2=t1/2,t3=t2/2,tk=1；
·按增量序列个数k，对序列进行k 趟排序；
·每趟排序，根据对应的增量ti，将待排序列分割成若干长度为n/ti的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
### 4.2 动画演示
![希尔排序](./utils/希尔排序.gif)
### 4.3 代码实现
```c++
void shellSort(vector<int> arr)
{
    int len =arr.size();
     for (int gap = len / 2; gap > 0; gap = gap / 2) {
        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行
        for (int i = gap; i < len; i++) {
            int j = i;
            int current = arr[i];
            while (j - gap >= 0 && current < arr[j - gap]) {
                 arr[j] = arr[j - gap];
                 j = j - gap;
            }
            arr[j] = current;
        }
    }
}
```
### 4.4算法分析
希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。希尔排序平均时间复杂度是$O(n^{1.3})$,最坏的时间复杂度为$O(n^2)$，最好的时间复杂度为递增序列$O(n)$。
## 5、归并排序（Merge Sort)
归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。
### 5.1 算法描述
1.把长度为n的输入序列分成两个长度为n/2的子序列；
2.对这两个子序列分别采用归并排序；
3.将两个排序好的子序列合并成一个最终的排序序列。
### 5.2 动图演示
![归并排序](./utils/归并排序.gif)
### 5.3 代码实现
```c++
void Merge(vector<int> &Array, int front, int mid, int end) {
    // preconditions:
    // Array[front...mid] is sorted
    // Array[mid+1 ... end] is sorted
    // Copy Array[front ... mid] to LeftSubArray
    // Copy Array[mid+1 ... end] to RightSubArray
    vector<int> LeftSubArray(Array.begin() + front, Array.begin() + mid + 1);
    vector<int> RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);
    int idxLeft = 0, idxRight = 0;
    LeftSubArray.insert(LeftSubArray.end(), numeric_limits<int>::max());
    RightSubArray.insert(RightSubArray.end(), numeric_limits<int>::max());
    // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]
    for (int i = front; i <= end; i++) {
        if (LeftSubArray[idxLeft] < RightSubArray[idxRight]) {
            Array[i] = LeftSubArray[idxLeft];
            idxLeft++;
        } else {
            Array[i] = RightSubArray[idxRight];
            idxRight++;
        }
    }
}
void MergeSort(vector<int> &Array, int front, int end) {
    if (front >= end)
        return;
    int mid = (front + end) / 2;
    MergeSort(Array, front, mid);
    MergeSort(Array, mid + 1, end);
    Merge(Array, front, mid, end);
}
```
### 5.4 算法分析
归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。

## 6、快速排序（Quick Sort)
快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
### 6.1 算法描述
快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：
·从数列中挑出一个元素，称为 “基准”（pivot）；
·重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
·递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
### 6.2 动图演示
![快速排序](./utils/快速排序.gif)
![快速排序](./utils/快速排序.png)
### 6.3 代码实现
```c++
void quickSort(int left, int right, vector<int>& arr)
{
	if(left >= right)
		return;
	int i, j, base, temp;
	i = left, j = right;
	base = arr[left];  //取最左边的数为基准数
	while (i < j)
	{
		while (arr[j] >= base && i < j)
			j--;
		while (arr[i] <= base && i < j)
			i++;
		if(i < j)
		{
			temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}
	}
	//基准数归位
	arr[left] = arr[i];
	arr[i] = base;
	quickSort(left, i - 1, arr);//递归左边
	quickSort(i + 1, right, arr);//递归右边
}
```
### 6.4 算法分析
快排时间复杂度是$O(nlogn)$，最坏的时间复杂度是$O(n^2)$（此时退化为冒泡排序）,最好的情况是$O(nlogn)$。空间复杂度为$O(nlogn)$，因为二分栈递归暂用。

## 7、堆排序（Heap Sort）
堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
### 7.1 算法描述
·将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
·将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
·由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。
### 7.2 动图演示
![堆排序](./utils/堆排序.gif)
### 7.3 代码实现
```c++
void Heap_build(vector<int>a,int root,int length)
{
    int lchild = root*2+1;//根节点的左子结点下标
    if (lchild < length)//左子结点下标不能超出数组的长度
    {
        int flag = lchild;//flag保存左右节点中最大值的下标
        int rchild = lchild+1;//根节点的右子结点下标
        if (rchild < length)//右子结点下标不能超出数组的长度(如果有的话)
        {
            if (a[rchild] > a[flag])//找出左右子结点中的最大值
            {
                flag = rchild;
            }
        }
        if (a[root] < a[flag])
        {
            //交换父结点和比父结点大的最大子节点
            swap(a[root],a[flag]);
            //从此次最大子节点的那个位置开始递归建堆
            Heap_build(a,flag,length);
        }
    }
}
 
void Heap_sort(vector<int>arr)
{
    int len =arr.size();
    for (int i = len/2; i >= 0; --i)//从最后一个非叶子节点的父结点开始建堆
    {
        Heap_build(arr,i,len);
    }
 
    for (int j = len-1; j > 0; --j)//j表示数组此时的长度，因为len长度已经建过了，从len-1开始
    {
        swap(arr[0],arr[j]);//交换首尾元素,将最大值交换到数组的最后位置保存
        Heap_build(arr,0,j);//去除最后位置的元素重新建堆，此处j表示数组的长度，最后一个位置下标变为len-2
    }
 
}
```
### 7.4 算法分析
堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成。由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。堆排序是就地排序，辅助空间为O(1)。它是不稳定的排序方法。

## 8、计数排序（Counting Sort）
计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
### 8.1算法描述
·找出待排序的数组中最大和最小的元素；
·统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
·对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
·反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。
### 8.2动图演示
![计数排序](./utils/计数排序.gif)
### 8.3代码实现
```c++
void CountSort(vector<int> &arr, int maxVal) {
	int len = arr.size();
	if (len < 1)
		return;
	vector<int> count(maxVal+1, 0);
	vector<int> tmp(arr);
	for (auto x : arr)
		count[x]++;
	for (int i = 1; i <= maxVal; ++i)
		count[i] += count[i - 1];
	for (int i = len - 1; i >= 0; --i) {
		arr[count[tmp[i]] - 1] = tmp[i];
		count[tmp[i]]--;				//注意这里要减1
	}
}
```
### 8.4算法分析
计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。
## 9、桶排序（Bucket Sort）
桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。
### 9.1算法描述
·设置一个定量的数组当作空桶；
·遍历输入数据，并且把数据一个一个放到对应的桶里去；
·对每个不是空的桶进行排序；
·从不是空的桶里把排好序的数据拼接起来。
 ### 9.2动图演示
 ![桶排序](./utils/桶排序.gif)
 ### 9.3代码实现
 ```c++
void BucketSort(vector<int> arr,int maxValue,int minValue) {
    int size=maxVal-minValue+1;//设置桶的个数
    vector<vector<int>>buckets(size);
    // 1.计数,将数组arr中的元素放到桶中
    for(i = 0; i < n; i++)
      buckets[(arr[i] - minValue) / bucketSize].push_back(arr[i])；
    // 2.排序
    for(i = 0, j = 0; i < size; i++) {
        for (i = 0; i < buckets.length; i++) {
        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排int序
        for (int j = 0; j < buckets[i].size(); j++) {
            arr.push(buckets[i][j]);                     
        }
        }
    }
}
 ```
 ### 9.4算法分析
 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 

 ## 10、基数排序（Radix Sort）
 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。
 ### 10.1算法描述
·取得数组中的最大数，并取得位数；
·arr为原始数组，从最低位开始取每个位组成radix数组；
·对radix进行计数排序（利用计数排序适用于小范围数的特点）；
### 10.2动图演示
![基数排序](./utils/基数排序.gif)
### 10.3代码实现void
```c++
int maxbit(int data[], int n) //辅助函数，求数据的最大位数
{
    int maxData = data[0];              ///< 最大数
    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。
    for (int i = 1; i < n; ++i)
    {
        if (maxData < data[i])
            maxData = data[i];
    }
    int d = 1;
    int p = 10;
    while (maxData >= p)
    {
        //p *= 10; // Maybe overflow
        maxData /= 10;
        ++d;
    }
    return d;
/*    int d = 1; //保存最大的位数
    int p = 10;
    for(int i = 0; i < n; ++i)
    {
        while(data[i] >= p)
        {
            p *= 10;
            ++d;
        }
    }
    return d;*/
}
void radixsort(int data[], int n) //基数排序
{
    int d = maxbit(data, n);
    int *tmp = new int[n];
    int *count = new int[10]; //计数器
    int i, j, k;
    int radix = 1;
    for(i = 1; i <= d; i++) //进行d次排序
    {
        for(j = 0; j < 10; j++)
            count[j] = 0; //每次分配前清空计数器
        for(j = 0; j < n; j++)
        {
            k = (data[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(j = 1; j < 10; j++)
            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (data[j] / radix) % 10;
            tmp[count[k] - 1] = data[j];
            count[k]--;
        }
        for(j = 0; j < n; j++) //将临时数组的内容复制到data中
            data[j] = tmp[j];
        radix = radix * 10;
    }
    delete []tmp;
    delete []count;
}
```
### 10.4算法分析
基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。
基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n>>k，因此额外空间需要大概n个左右。